/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package backgammon;

import java.util.List;
import java.util.Map;
import java.util.Set;

import processing.core.PApplet;
import processing.core.PGraphics;
import processing.core.PImage;

public class App extends PApplet{
	
	GameEngine b = new AL();
	List<Integer> positions = List.of(0,66,140,214,288,362,436,562,636,710,784,858,932,932,858,784,710,636,562,436,362,288,214,140,66);
	
    public static void main(String[] args) { PApplet.runSketch(new String[]{"Backgammon"}, new App()); }
    
	public PImage img;
	boolean gamestarted, diceIsRollable, showWinMessage;
	PGraphics p, q, z, x, y;
	int FROMFIELD, TOFIELD, winner;
	
    public void settings() {
    
    	super.size(1179, 833);
    
    }
    public void setup() {
    	p = createGraphics(1179, 833);
    	q = createGraphics(1179, 833);
    	z = createGraphics(1179, 833);
    	x = createGraphics(1179, 833);
    	y = createGraphics(1179, 833);
    	img = loadImage("/src/main/resources/bg.png");
    	b.defaultStoneStructure();
    }
    
    
    public void draw() {
    	super.background(img);
    	if(gamestarted) {
    		
    		if(b.checkforWin()) {
    			win();
    			return;
    		}
    		
    		drawStones(b.getBlackPos(), 0, p);
        	drawStones(b.getWhitePos(), 255, q);
        	drawCurrentPlayer();
        	drawKickedStones();
        	drawRemainingStones(); //BASE GAME DRAWING OPERATIONS

        	if(!diceIsRollable) { //if dice got rolled do the following action:
        		drawDiceValues();
        		
        		if(b.getDiceValues().isEmpty()) {
					b.nextPlayer();
					diceIsRollable = true;
				}
        		
        		drawHighlightStones();
        		
        	} else {
        		drawDiceButton();
        	}
    	} else {  //if game not started show the start button
    		
    		if(showWinMessage) {
    			String winnertext = winner == 1 ? "White player won!" : "Black player won!"; 
    			x.beginDraw();
    	    	x.clear();
    			x.text(winnertext, 600, 400);
    			x.fill(0);
    			x.textSize(40);
    	    	x.endDraw();
    	    	image(x, 0, 0);
    			
    		}
    		
    		drawStartButton(); 
    	}
    	
    }
    
    private boolean fieldIsClicked(){
    	return positions.stream().anyMatch(n -> n >= mouseX-25 && n <= mouseX+25) && gamestarted; //check if the mouseX matches any field in the radius of a stone
    }
    
    private int getField() {
    	int absolutepos = positions.stream().filter(n -> n >= mouseX-25 && n <= mouseX+25).findFirst().get(); //get the absolute field position to the relative mouseX 
    	return (mouseY > 416) ? positions.indexOf(absolutepos) : positions.lastIndexOf(absolutepos); // gives the index (--> field number) of the position
    }
    
    private void drawStones(Map<Integer, Integer> map, int color, PGraphics g) {
    	g.beginDraw();
    	g.clear();
    	
    	map.forEach((field, amount) -> {
    		for(int i = 0; i < amount; i++) {
    			int y = (field >  12) ? 52 + (i * 52) : 772 - (i * 52);
				new Stone(positions.get(field), y, color).draw(g);
			}
    	});
    	
    	g.endDraw();
		image(g, 0, 0);
    }
    
	private void drawHighlightStones() {
		//if a stone is selected show fields where it can go to 
		if(FROMFIELD != 0) drawMovableStones(b.calcNewPos(FROMFIELD), y, 0);
		
		//if white needs to reenter show possible reenter fields
		if(b.getWhiteKicked() > 0) drawMovableStones(b.calcNewPos(0), y, 0);
		
		//if black needs to reenter show possible reenter fields
		if(b.getBlackKicked() > 0) drawMovableStones(b.calcNewPos(25), y, 0);
		
		//if no stone selected so far show stones that are possible to move
		if(FROMFIELD == 0) drawMovableStones(b.getMovableStones(), y, 1);
	}
    
    private void drawMovableStones(Set<Integer> fields, PGraphics g, int mode) {
    	g.beginDraw();
    	g.clear();
    	fields.forEach(field -> {
    		int amount = 0;
    		int color;
    		if(mode == 1) { //mode 1 marks the top stones of every field, of which the current player can perform a move (called before making a move)
    			amount = b.getCurrentPlayer() == 1 ? b.getWhitePos().get(field)-1 : b.getBlackPos().get(field)-1;
    			color = color(0, 191, 255, 127);
    		} else { //otherwise this mode is called, where the player already selected a field where to start from. In this case the game will add a new stone on top of every field where the player is able to go to
    			if(b.getCurrentPlayer() == 1 && b.getWhitePos().containsKey(field)) amount = b.getWhitePos().get(field);
    			else if(b.getCurrentPlayer() == -1 && b.getBlackPos().containsKey(field)) amount = b.getBlackPos().get(field);
    			color = color(255, 204, 0, 127);
    		}
    		int y = (field >  12) ? 52 + (amount * 52) : 772 - (amount * 52);
    		new Stone(positions.get(field), y, color).draw(g);
    	});
    	g.endDraw();
		image(g, 0, 0);
    }
    
    private void drawKickedStones() {
    	text("Kicked Stones:", 980, 700);
		fill(255);
		
    	x.beginDraw(); x.clear();
    	
    	new Stone(1010, 750, 0).draw(x);
    	x.text(b.getWhiteKicked(), 1000, 760); x.fill(0); x.textSize(30);
		
    	new Stone(1070, 750, 255).draw(x);
    	x.text(b.getBlackKicked(), 1060, 760); x.fill(255); x.textSize(30);
    	
    	x.endDraw();
    	image(x, 0, 0);
	}
    private void drawRemainingStones() {
    	text("Remaining Stones:", 970, 600);
		fill(255);
		
    	x.beginDraw();
    	x.clear();
    	
    	new Stone(1010, 650, 0).draw(x);
    	x.text(b.getStoneCount(1), 990, 660);
		x.fill(0);
		x.textSize(30);
		
    	new Stone(1070, 650, 255).draw(x);
    	x.text(b.getStoneCount(-1), 1050, 660);
		x.fill(255);
		x.textSize(30);
    	
    	x.endDraw();
    	image(x, 0, 0);
	}
	private void drawCurrentPlayer() {
    	z.beginDraw();
    	z.clear();
    	new Stone(1100, 50, b.getCurrentPlayer() == 1 ? 255 : 0).draw(z);
    	z.endDraw();
    	image(z, 0, 0);
	}
	private void drawStartButton() {
		rect(1000, 284, 150, 50);
		fill(0);
		text("Start game", 1010, 284+32);
		fill(255);
		textSize(24);
        if(mouseX >= 1000 && mouseX <= 1150 && mouseY > 284 && mouseY < 334 && mousePressed) {
        	gamestarted = true;
        	diceIsRollable = true;
        	b.chooseRandomPlayer();
        }
	}
    private void drawDiceButton() {
		rect(1000, 384, 150, 50);
		fill(0);
		text("Roll dice", 1010, 384+32);
		fill(255);
		textSize(24);
        if(mouseX >= 1000 && mouseX <= 1150 && mouseY > 384 && mouseY < 434 && mousePressed && diceIsRollable) {
        	b.rollDices();
        	diceIsRollable = false;
        }
	}
    private void drawDiceValues() {
    	if(!b.getDiceValues().isEmpty()) {
    		text(b.getDiceValues().toString(), 1010, 500);
    		textSize(24);
    	}
    }
	private void win() {
		winner = b.getCurrentPlayer();
		showWinMessage = true;
		gamestarted = false; 
		diceIsRollable = false;
    	b.defaultStoneStructure();
	}
	
	
	//GAME MECHANICS ON GUI SIDE -> SETTING FROM FIELD; TO FIELD; PERFORMING MOVING OPERATIONS ACCESSING BACKEND
	
	public void mouseClicked() {
		if(!diceIsRollable && gamestarted) {
			if(b.isBlocked()) { //if player is either blocked (cannot perform any move) or has no dice numbers left, switch player
				b.nextPlayer();
				diceIsRollable = true;
				return;
			}
			if((b.getCurrentPlayer() == 1 && b.getWhiteKicked() == 0) || (b.getCurrentPlayer() == -1 && b.getBlackKicked() == 0)) { //in order to fullfill a move, the current players kicked stone count has to be on zero
				
				if(fieldIsClicked() && getField() != 0) { //check if the player clicked on a field 
					if(FROMFIELD == 0) { //if player hasnt marked a starting point yet, set the field as starting point
						FROMFIELD = getField();
					} 
					
					else if(FROMFIELD != 0 && TOFIELD == 0) {  //if starting point is set, but no target location, set it.
						TOFIELD = getField();
						
						if(b.canPutOut() && FROMFIELD == TOFIELD) { //if player is able to take out a stone and he performed a double click on a stone, take it out
							b.takeOut(FROMFIELD);
							System.out.println("TOOK ONE OUT FROM "+FROMFIELD);
						} 
						
						else if(TOFIELD != FROMFIELD && b.move(FROMFIELD, getField())) { //if starting and end point are different, and the move resulted in a success, print success message
							System.out.println("MOVED FROM "+FROMFIELD + " TO "+TOFIELD);
						} 
						
						FROMFIELD = 0; TOFIELD = 0; //after every operation (successful or not) reset start and endpoint
					}
				}
			} else {
				
				/*
				 * Special case: Kicked stone
				 * 
				 * Player 1: conditions to reenter:
				 * field is clicked and between 1 and 6
				 * 
				 * Player 2: conditions:
				 * field is clicked and between 19 and 24
				 * 
				 * Afterwards, check in both cases whether a reenter is possible (if the player has the dice number to reenter and no stone is blocking the field)
				 */
				if(fieldIsClicked() && ((b.getCurrentPlayer() == 1 && b.getWhiteKicked() > 0 && getField() > 0 && getField() < 7) 
					|| (b.getCurrentPlayer() == -1 && b.getBlackKicked() > 0 && getField() > 18 && getField() < 25))) {
					int field = getField();
					//if the player is able to reenter (for this case the field he clicked on needs to be one of his dice numbers AND the opponent should not block it)
					if(b.canReenter(field)) b.reenter(field);
				}
			}
		}

    }
}
